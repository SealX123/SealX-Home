define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function (e, s, t) {
	"use strict";

	function n(e) {
		e = (new Date).toLocaleString("en-us", e);
		return 1 == e.length ? "0" + e : e
	}
	var o = e("./lib/dom"),
		i = e("./lib/oop"),
		r = e("./lib/event_emitter").EventEmitter,
		p = e("./lib/lang"),
		l = e("./range").Range,
		h = e("./range_list").RangeList,
		a = e("./keyboard/hash_handler").HashHandler,
		c = e("./tokenizer").Tokenizer,
		u = e("./clipboard"),
		d = {
			CURRENT_WORD: function (e) {
				return e.session.getTextRange(e.session.getWordRange())
			},
			SELECTION: function (e, t, n) {
				e = e.session.getTextRange();
				return n ? e.replace(/\n\r?([ \t]*\S)/g, "\n" + n + "$1") : e
			},
			CURRENT_LINE: function (e) {
				return e.session.getLine(e.getCursorPosition().row)
			},
			PREV_LINE: function (e) {
				return e.session.getLine(e.getCursorPosition().row - 1)
			},
			LINE_INDEX: function (e) {
				return e.getCursorPosition().row
			},
			LINE_NUMBER: function (e) {
				return e.getCursorPosition().row + 1
			},
			SOFT_TABS: function (e) {
				return e.session.getUseSoftTabs() ? "YES" : "NO"
			},
			TAB_SIZE: function (e) {
				return e.session.getTabSize()
			},
			CLIPBOARD: function (e) {
				return u.getText && u.getText()
			},
			FILENAME: function (e) {
				return /[^/\\]*$/.exec(this.FILEPATH(e))[0]
			},
			FILENAME_BASE: function (e) {
				return /[^/\\]*$/.exec(this.FILEPATH(e))[0].replace(/\.[^.]*$/, "")
			},
			DIRECTORY: function (e) {
				return this.FILEPATH(e).replace(/[^/\\]*$/, "")
			},
			FILEPATH: function (e) {
				return "/not implemented.txt"
			},
			WORKSPACE_NAME: function () {
				return "Unknown"
			},
			FULLNAME: function () {
				return "Unknown"
			},
			BLOCK_COMMENT_START: function (e) {
				e = e.session.$mode || {};
				return e.blockComment && e.blockComment.start || ""
			},
			BLOCK_COMMENT_END: function (e) {
				e = e.session.$mode || {};
				return e.blockComment && e.blockComment.end || ""
			},
			LINE_COMMENT: function (e) {
				return (e.session.$mode || {}).lineCommentStart || ""
			},
			CURRENT_YEAR: n.bind(null, {
				year: "numeric"
			}),
			CURRENT_YEAR_SHORT: n.bind(null, {
				year: "2-digit"
			}),
			CURRENT_MONTH: n.bind(null, {
				month: "numeric"
			}),
			CURRENT_MONTH_NAME: n.bind(null, {
				month: "long"
			}),
			CURRENT_MONTH_NAME_SHORT: n.bind(null, {
				month: "short"
			}),
			CURRENT_DATE: n.bind(null, {
				day: "2-digit"
			}),
			CURRENT_DAY_NAME: n.bind(null, {
				weekday: "long"
			}),
			CURRENT_DAY_NAME_SHORT: n.bind(null, {
				weekday: "short"
			}),
			CURRENT_HOUR: n.bind(null, {
				hour: "2-digit",
				hour12: !1
			}),
			CURRENT_MINUTE: n.bind(null, {
				minute: "2-digit"
			}),
			CURRENT_SECOND: n.bind(null, {
				second: "2-digit"
			})
		},
		g = (d.SELECTED_TEXT = d.SELECTION, f.prototype.getTokenizer = function () {
			return f.$tokenizer || this.createTokenizer()
		}, f.prototype.createTokenizer = function () {
			function o(e) {
				return e = e.substr(1), /^\d+$/.test(e) ? [{
					tabstopId: parseInt(e, 10)
				}] : [{
					text: e
				}]
			}

			function e(e) {
				return "(?:[^\\\\" + e + "]|\\\\.)"
			}
			var t = {
				regex: "/(" + e("/") + "+)/",
				onMatch: function (e, t, n) {
					n = n[0];
					return n.fmtString = !0, n.guard = e.slice(1, -1), n.flag = ""
				},
				next: "formatString"
			};
			return f.$tokenizer = new c({
				start: [{
					regex: /\\./,
					onMatch: function (e, t, n) {
						var o = e[1];
						return [e = "}" == o && n.length || -1 != "`$\\".indexOf(o) ? o : e]
					}
				}, {
					regex: /}/,
					onMatch: function (e, t, n) {
						return [n.length ? n.shift() : e]
					}
				}, {
					regex: /\$(?:\d+|\w+)/,
					onMatch: o
				}, {
					regex: /\$\{[\dA-Z_a-z]+/,
					onMatch: function (e, t, n) {
						e = o(e.substr(1));
						return n.unshift(e[0]), e
					},
					next: "snippetVar"
				}, {
					regex: /\n/,
					token: "newline",
					merge: !1
				}],
				snippetVar: [{
					regex: "\\|" + e("\\|") + "*\\|",
					onMatch: function (e, t, n) {
						e = e.slice(1, -1).replace(/\\[,|\\]|,/g, function (e) {
							return 2 == e.length ? e[1] : "\0"
						}).split("\0").map(function (e) {
							return {
								value: e
							}
						});
						return [(n[0].choices = e)[0]]
					},
					next: "start"
				}, t, {
					regex: "([^:}\\\\]|\\\\.)*:?",
					token: "",
					next: "start"
				}],
				formatString: [{
					regex: /:/,
					onMatch: function (e, t, n) {
						return n.length && n[0].expectElse ? (n[0].expectElse = !1, n[0].ifEnd = {
							elseEnd: n[0]
						}, [n[0].ifEnd]) : ":"
					}
				}, {
					regex: /\\./,
					onMatch: function (e, t, n) {
						var o = e[1];
						return "}" == o && n.length || -1 != "`$\\".indexOf(o) ? e = o : "n" == o ? e = "\n" : "t" == o ? e = "\t" : -1 != "ulULE".indexOf(o) && (e = {
							changeCase: o,
							local: "a" < o
						}), [e]
					}
				}, {
					regex: "/\\w*}",
					onMatch: function (e, t, n) {
						n = n.shift();
						return n && (n.flag = e.slice(1, -1)), this.next = n && n.tabstopId ? "start" : "", [n || e]
					},
					next: "start"
				}, {
					regex: /\$(?:\d+|\w+)/,
					onMatch: function (e, t, n) {
						return [{
							text: e.slice(1)
						}]
					}
				}, {
					regex: /\${\w+/,
					onMatch: function (e, t, n) {
						e = {
							text: e.slice(2)
						};
						return n.unshift(e), [e]
					},
					next: "formatStringVar"
				}, {
					regex: /\n/,
					token: "newline",
					merge: !1
				}, {
					regex: /}/,
					onMatch: function (e, t, n) {
						n = n.shift();
						return this.next = n && n.tabstopId ? "start" : "", [n || e]
					},
					next: "start"
				}],
				formatStringVar: [{
					regex: /:\/\w+}/,
					onMatch: function (e, t, n) {
						return n[0].formatFunction = e.slice(2, -1), [n.shift()]
					},
					next: "formatString"
				}, t, {
					regex: /:[\?\-+]?/,
					onMatch: function (e, t, n) {
						"+" == e[1] && (n[0].ifEnd = n[0]), "?" == e[1] && (n[0].expectElse = !0)
					},
					next: "formatString"
				}, {
					regex: "([^:}\\\\]|\\\\.)*:?",
					token: "",
					next: "formatString"
				}]
			})
		}, f.prototype.tokenizeTmSnippet = function (e, t) {
			return this.getTokenizer().getLineTokens(e, t).tokens.map(function (e) {
				return e.value || e
			})
		}, f.prototype.getVariableValue = function (e, t, n) {
			if (/^\d+$/.test(t)) return (this.variables.__ || {})[t] || "";
			if (/^[A-Z]\d+$/.test(t)) return (this.variables[t[0] + "__"] || {})[t.substr(1)] || "";
			if (t = t.replace(/^TM_/, ""), !this.variables.hasOwnProperty(t)) return "";
			var o = this.variables[t];
			return null == (o = "function" == typeof o ? this.variables[t](e, t, n) : o) ? "" : o
		}, f.prototype.tmStrFormat = function (e, t, s) {
			if (!t.fmt) return e;
			var n = t.flag || "",
				o = t.guard,
				o = new RegExp(o, n.replace(/[^gim]/g, "")),
				a = "string" == typeof t.fmt ? this.tokenizeTmSnippet(t.fmt, "formatString") : t.fmt,
				c = this;
			return e.replace(o, function () {
				for (var e = c.variables.__, t = (c.variables.__ = [].slice.call(arguments), c.resolveVariables(a, s)), n = "E", o = 0; o < t.length; o++) {
					var i, r = t[o];
					"object" == typeof r ? (t[o] = "", r.changeCase && r.local ? (i = t[o + 1]) && "string" == typeof i && ("u" == r.changeCase ? t[o] = i[0].toUpperCase() : t[o] = i[0].toLowerCase(), t[o + 1] = i.substr(1)) : r.changeCase && (n = r.changeCase)) : "U" == n ? t[o] = r.toUpperCase() : "L" == n && (t[o] = r.toLowerCase())
				}
				return c.variables.__ = e, t.join("")
			})
		}, f.prototype.tmFormatFunction = function (e, t, n) {
			return "upcase" == t.formatFunction ? e.toUpperCase() : "downcase" == t.formatFunction ? e.toLowerCase() : e
		}, f.prototype.resolveVariables = function (t, e) {
			function n(e) {
				e = t.indexOf(e, s + 1); - 1 != e && (s = e)
			}
			for (var o = [], i = "", r = !0, s = 0; s < t.length; s++) {
				var a, c = t[s];
				"string" == typeof c ? (o.push(c), "\n" == c ? (r = !0, i = "") : r && (i = /^\t*/.exec(c)[0], r = /\S/.test(c))) : c && (r = !1, c.fmtString && (-1 == (a = t.indexOf(c, s + 1)) && (a = t.length), c.fmt = t.slice(s + 1, a), s = a), c.text ? (a = this.getVariableValue(e, c.text, i) + "", c.fmtString && (a = this.tmStrFormat(a, c, e)), (a = c.formatFunction ? this.tmFormatFunction(a, c, e) : a) && !c.ifEnd ? (o.push(a), n(c)) : !a && c.ifEnd && n(c.ifEnd)) : c.elseEnd ? n(c.elseEnd) : null == c.tabstopId && null == c.changeCase || o.push(c))
			}
			return o
		}, f.prototype.getDisplayTextForSnippet = function (e, t) {
			return m.call(this, e, t).text
		}, f.prototype.insertSnippetForSelection = function (e, t, n) {
			var t = m.call(this, e, t, n = void 0 === n ? {} : n),
				o = e.getSelectionRange(),
				n = (n.range && 0 === n.range.compareRange(o) && (o = n.range), e.session.replace(o, t.text)),
				i = new b(e),
				e = e.inVirtualSelectionMode && e.selection.index;
			i.addTabstops(t.tabstops, o.start, n, e)
		}, f.prototype.insertSnippet = function (e, t, n) {
			var o = this;
			if (!(n = void 0 === n ? {} : n).range || n.range instanceof l || (n.range = l.fromPoints(n.range.start, n.range.end)), e.inVirtualSelectionMode) return o.insertSnippetForSelection(e, t, n);
			e.forEachSelection(function () {
				o.insertSnippetForSelection(e, t, n)
			}, null, {
				keepOrder: !0
			}), e.tabstopManager && e.tabstopManager.tabNext()
		}, f.prototype.$getScope = function (e) {
			var t, n = e.session.$mode.$id || "";
			return "html" !== (n = n.split("/").pop()) && "php" !== n || ("php" !== n || e.session.$mode.inlinePhp || (n = "html"), t = e.getCursorPosition(), (e = "object" == typeof (e = e.session.getState(t.row)) ? e[0] : e).substring && ("js-" == e.substring(0, 3) ? n = "javascript" : "css-" == e.substring(0, 4) ? n = "css" : "php-" == e.substring(0, 4) && (n = "php"))), n
		}, f.prototype.getActiveScopes = function (e) {
			var e = this.$getScope(e),
				t = [e],
				n = this.snippetMap;
			return n[e] && n[e].includeScopes && t.push.apply(t, n[e].includeScopes), t.push("_"), t
		}, f.prototype.expandWithTab = function (e, t) {
			var n = this,
				o = e.forEachSelection(function () {
					return n.expandSnippetForSelection(e, t)
				}, null, {
					keepOrder: !0
				});
			return o && e.tabstopManager && e.tabstopManager.tabNext(), o
		}, f.prototype.expandSnippetForSelection = function (e, t) {
			var n, o = e.getCursorPosition(),
				i = e.session.getLine(o.row),
				r = i.substring(0, o.column),
				s = i.substr(o.column),
				a = this.snippetMap;
			return this.getActiveScopes(e).some(function (e) {
				e = a[e];
				return !!(n = e ? this.findMatchingSnippet(e, r, s) : n)
			}, this), !!n && (t && t.dryRun || (e.session.doc.removeInLine(o.row, o.column - n.replaceBefore.length, o.column + n.replaceAfter.length), this.variables.M__ = n.matchBefore, this.variables.T__ = n.matchAfter, this.insertSnippetForSelection(e, n.content), this.variables.M__ = this.variables.T__ = null), !0)
		}, f.prototype.findMatchingSnippet = function (e, t, n) {
			for (var o = e.length; o--;) {
				var i = e[o];
				if ((!i.startRe || i.startRe.test(t)) && ((!i.endRe || i.endRe.test(n)) && (i.startRe || i.endRe))) return i.matchBefore = i.startRe ? i.startRe.exec(t) : [""], i.matchAfter = i.endRe ? i.endRe.exec(n) : [""], i.replaceBefore = i.triggerRe ? i.triggerRe.exec(t)[0] : "", i.replaceAfter = i.endTriggerRe ? i.endTriggerRe.exec(n)[0] : "", i
			}
		}, f.prototype.register = function (t, o) {
			function i(e) {
				return (e = e && !/^\^?\(.*\)\$?$|^\\b$/.test(e) ? "(?:" + e + ")" : e) || ""
			}

			function r(e, t, n) {
				return e = i(e), t = i(t), n ? (e = t + e) && "$" != e[e.length - 1] && (e += "$") : (e += t) && "^" != e[0] && (e = "^" + e), new RegExp(e)
			}

			function n(e) {
				e.scope || (e.scope = o || "_"), o = e.scope, s[o] || (s[o] = [], a[o] = {});
				var t, n = a[o];
				e.name && ((t = n[e.name]) && c.unregister(t), n[e.name] = e), s[o].push(e), e.prefix && (e.tabTrigger = e.prefix), !e.content && e.body && (e.content = Array.isArray(e.body) ? e.body.join("\n") : e.body), e.tabTrigger && !e.trigger && (!e.guard && /^\w/.test(e.tabTrigger) && (e.guard = "\\b"), e.trigger = p.escapeRegExp(e.tabTrigger)), (e.trigger || e.guard || e.endTrigger || e.endGuard) && (e.startRe = r(e.trigger, e.guard, !0), e.triggerRe = new RegExp(e.trigger), e.endRe = r(e.endTrigger, e.endGuard, !0), e.endTriggerRe = new RegExp(e.endTrigger))
			}
			var s = this.snippetMap,
				a = this.snippetNameMap,
				c = this;
			t = t || [], Array.isArray(t) ? t.forEach(n) : Object.keys(t).forEach(function (e) {
				n(t[e])
			}), this._signal("registerSnippets", {
				scope: o
			})
		}, f.prototype.unregister = function (e, n) {
			function t(e) {
				var t = i[e.scope || n];
				t && t[e.name] && (delete t[e.name], 0 <= (e = (t = o[e.scope || n]) && t.indexOf(e)) && t.splice(e, 1))
			}
			var o = this.snippetMap,
				i = this.snippetNameMap;
			e.content ? t(e) : Array.isArray(e) && e.forEach(t)
		}, f.prototype.parseSnippetFile = function (e) {
			e = e.replace(/\r/g, "");
			for (var t, n, o, i = [], r = {}, s = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm; n = s.exec(e);) {
				if (n[1]) try {
					r = JSON.parse(n[1]), i.push(r)
				} catch (e) {}
				n[4] ? (r.content = n[4].replace(/^\t/gm, ""), i.push(r), r = {}) : (t = n[2], n = n[3], "regex" == t ? (r.guard = (o = /\/((?:[^\/\\]|\\.)*)|$/g).exec(n)[1], r.trigger = o.exec(n)[1], r.endTrigger = o.exec(n)[1], r.endGuard = o.exec(n)[1]) : "snippet" == t ? (r.tabTrigger = n.match(/^\S*/)[0], r.name || (r.name = n)) : t && (r[t] = n))
			}
			return i
		}, f.prototype.getSnippetByName = function (t, e) {
			var n, o = this.snippetNameMap;
			return this.getActiveScopes(e).some(function (e) {
				e = o[e];
				return !!(n = e ? e[t] : n)
			}, this), n
		}, f);

	function f() {
		this.snippetMap = {}, this.snippetNameMap = {}, this.variables = d
	}
	i.implement(g.prototype, r);
	var m = function (e, t, n) {
			void 0 === n && (n = {});
			var o = e.getCursorPosition(),
				i = e.session.getLine(o.row),
				r = e.session.getTabString(),
				s = i.match(/^\s*/)[0],
				a = (o.column < s.length && (s = s.slice(0, o.column)), t = t.replace(/\r/g, ""), this.tokenizeTmSnippet(t));
			a = (a = this.resolveVariables(a, e)).map(function (e) {
				return "\n" != e || n.excludeExtraIndent ? "string" == typeof e ? e.replace(/\t/g, r) : e : e + s
			});
			for (var c = [], p = (a.forEach(function (e, t) {
					var n, o;
					"object" == typeof e && (o = e.tabstopId, (n = c[o]) || ((n = c[o] = []).index = o, n.value = "", n.parents = {}), -1 === n.indexOf(e) && (e.choices && !n.choices && (n.choices = e.choices), n.push(e), -1 !== (o = a.indexOf(e, t + 1)) && ((e = a.slice(t + 1, o)).some(function (e) {
						return "object" == typeof e
					}) && !n.value ? n.value = e : !e.length || n.value && "string" == typeof n.value || (n.value = e.join("")))))
				}), c.forEach(function (e) {
					e.length = 0
				}), {}), l = 0; l < a.length; l++) {
				var h, u, d, g = a[l];
				"object" == typeof g && (d = g.tabstopId, h = c[d], u = a.indexOf(g, l + 1), p[d] ? p[d] === g && (delete p[d], Object.keys(p).forEach(function (e) {
					h.parents[e] = !0
				})) : (p[d] = g, "string" != typeof (d = h.value) ? d = function (e) {
					for (var t = [], n = 0; n < e.length; n++) {
						if ("object" == typeof (o = e[n])) {
							if (p[o.tabstopId]) continue;
							var o = t[e.lastIndexOf(o, n - 1)] || {
								tabstopId: o.tabstopId
							}
						}
						t[n] = o
					}
					return t
				}(d) : g.fmt && (d = this.tmStrFormat(d, g, e)), a.splice.apply(a, [l + 1, Math.max(0, u - l)].concat(d, g)), -1 === h.indexOf(g) && h.push(g)))
			}
			var f = 0,
				m = 0,
				b = "";
			return a.forEach(function (e) {
				var t;
				"string" == typeof e ? (1 < (t = e.split("\n")).length ? (m = t[t.length - 1].length, f += t.length - 1) : m += e.length, b += e) : e && (e.start ? e.end = {
					row: f,
					column: m
				} : e.start = {
					row: f,
					column: m
				})
			}), {
				text: b,
				tabstops: c,
				tokens: a
			}
		},
		b = (v.prototype.attach = function (e) {
			this.$openTabstops = null, this.selectedTabstop = null, this.editor = e, this.session = e.session, this.editor.on("change", this.$onChange), this.editor.on("changeSelection", this.$onChangeSelection), this.editor.on("changeSession", this.$onChangeSession), this.editor.commands.on("afterExec", this.$onAfterExec), this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler)
		}, v.prototype.detach = function () {
			this.tabstops.forEach(this.removeTabstopMarkers, this), this.ranges.length = 0, this.tabstops.length = 0, this.selectedTabstop = null, this.editor.off("change", this.$onChange), this.editor.off("changeSelection", this.$onChangeSelection), this.editor.off("changeSession", this.$onChangeSession), this.editor.commands.off("afterExec", this.$onAfterExec), this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.tabstopManager = null, this.session = null, this.editor = null
		}, v.prototype.onChange = function (e) {
			for (var t = "r" == e.action[0], n = this.selectedTabstop || {}, o = n.parents || {}, i = this.tabstops.slice(), r = 0; r < i.length; r++) {
				var s = i[r],
					a = s == n || o[s.index];
				if (s.rangeList.$bias = a ? 0 : 1, "remove" == e.action && s !== n)
					for (var a = s.parents && s.parents[n.index], c = (c = s.rangeList.pointIndex(e.start, a)) < 0 ? -c - 1 : c + 1, a = (a = s.rangeList.pointIndex(e.end, a)) < 0 ? -a - 1 : a - 1, p = s.rangeList.ranges.slice(c, a), l = 0; l < p.length; l++) this.removeRange(p[l]);
				s.rangeList.$onChange(e)
			}
			var h = this.session;
			this.$inChange || !t || 1 != h.getLength() || h.getValue() || this.detach()
		}, v.prototype.updateLinkedFields = function () {
			var e = this.selectedTabstop;
			if (e && e.hasLinkedRanges && e.firstNonLinked) {
				this.$inChange = !0;
				for (var t = this.session, n = t.getTextRange(e.firstNonLinked), o = 0; o < e.length; o++) {
					var i, r = e[o];
					r.linked && (i = r.original, i = s.snippetManager.tmStrFormat(n, i, this.editor), t.replace(r, i))
				}
				this.$inChange = !1
			}
		}, v.prototype.onAfterExec = function (e) {
			e.command && !e.command.readOnly && this.updateLinkedFields()
		}, v.prototype.onChangeSelection = function () {
			if (this.editor) {
				for (var e = this.editor.selection.lead, t = this.editor.selection.anchor, n = this.editor.selection.isEmpty(), o = 0; o < this.ranges.length; o++)
					if (!this.ranges[o].linked) {
						var i = this.ranges[o].contains(e.row, e.column),
							r = n || this.ranges[o].contains(t.row, t.column);
						if (i && r) return
					}
				this.detach()
			}
		}, v.prototype.onChangeSession = function () {
			this.detach()
		}, v.prototype.tabNext = function (e) {
			var t = this.tabstops.length,
				e = this.index + (e || 1),
				e = Math.min(Math.max(e, 1), t);
			this.selectTabstop(e = e == t ? 0 : e), 0 === e && this.detach()
		}, v.prototype.selectTabstop = function (e) {
			this.$openTabstops = null;
			var t = this.tabstops[this.index];
			if (t && this.addTabstopMarkers(t), this.index = e, (t = this.tabstops[this.index]) && t.length) {
				e = (this.selectedTabstop = t).firstNonLinked || t;
				if (t.choices && (e.cursor = e.start), this.editor.inVirtualSelectionMode) this.editor.selection.fromOrientedRange(e);
				else {
					var n = this.editor.multiSelect;
					n.toSingleRange(e);
					for (var o = 0; o < t.length; o++) t.hasLinkedRanges && t[o].linked || n.addRange(t[o].clone(), !0)
				}
				this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler), this.selectedTabstop && this.selectedTabstop.choices && this.editor.execCommand("startAutocomplete", {
					matches: this.selectedTabstop.choices
				})
			}
		}, v.prototype.addTabstops = function (e, s, t) {
			var a = this.useLink || !this.editor.getOption("enableMultiselect");
			this.$openTabstops || (this.$openTabstops = []), e[0] || (t = l.fromPoints(t, t), y(t.start, s), y(t.end, s), e[0] = [t], e[0].index = 0);
			var c = [this.index + 1, 0],
				p = this.ranges;
			e.forEach(function (e, t) {
				for (var n = this.$openTabstops[t] || e, o = 0; o < e.length; o++) {
					var i = e[o],
						r = l.fromPoints(i.start, i.end || i.start);
					x(r.start, s), x(r.end, s), r.original = i, r.tabstop = n, p.push(r), n != e ? n.unshift(r) : n[o] = r, i.fmtString || n.firstNonLinked && a ? (r.linked = !0, n.hasLinkedRanges = !0) : n.firstNonLinked || (n.firstNonLinked = r)
				}
				n.firstNonLinked || (n.hasLinkedRanges = !1), n === e && (c.push(n), this.$openTabstops[t] = n), this.addTabstopMarkers(n), n.rangeList = n.rangeList || new h, n.rangeList.$bias = 0, n.rangeList.addList(n)
			}, this), 2 < c.length && (this.tabstops.length && c.push(c.splice(2, 1)[0]), this.tabstops.splice.apply(this.tabstops, c))
		}, v.prototype.addTabstopMarkers = function (e) {
			var t = this.session;
			e.forEach(function (e) {
				e.markerId || (e.markerId = t.addMarker(e, "ace_snippet-marker", "text"))
			})
		}, v.prototype.removeTabstopMarkers = function (e) {
			var t = this.session;
			e.forEach(function (e) {
				t.removeMarker(e.markerId), e.markerId = null
			})
		}, v.prototype.removeRange = function (e) {
			var t = e.tabstop.indexOf(e); - 1 != t && e.tabstop.splice(t, 1), -1 != (t = this.ranges.indexOf(e)) && this.ranges.splice(t, 1), -1 != (t = e.tabstop.rangeList.ranges.indexOf(e)) && e.tabstop.splice(t, 1), this.session.removeMarker(e.markerId), e.tabstop.length || (-1 != (t = this.tabstops.indexOf(e.tabstop)) && this.tabstops.splice(t, 1), this.tabstops.length || this.detach())
		}, v);

	function v(e) {
		if (this.index = 0, this.ranges = [], this.tabstops = [], e.tabstopManager) return e.tabstopManager;
		(e.tabstopManager = this).$onChange = this.onChange.bind(this), this.$onChangeSelection = p.delayedCall(this.onChangeSelection.bind(this)).schedule, this.$onChangeSession = this.onChangeSession.bind(this), this.$onAfterExec = this.onAfterExec.bind(this), this.attach(e)
	}
	b.prototype.keyboardHandler = new a, b.prototype.keyboardHandler.bindKeys({
		Tab: function (e) {
			s.snippetManager && s.snippetManager.expandWithTab(e) || (e.tabstopManager.tabNext(1), e.renderer.scrollCursorIntoView())
		},
		"Shift-Tab": function (e) {
			e.tabstopManager.tabNext(-1), e.renderer.scrollCursorIntoView()
		},
		Esc: function (e) {
			e.tabstopManager.detach()
		}
	});
	var x = function (e, t) {
			0 == e.row && (e.column += t.column), e.row += t.row
		},
		y = function (e, t) {
			e.row == t.row && (e.column -= t.column), e.row -= t.row
		},
		i = (o.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}", "snippets.css", !1), s.snippetManager = new g, e("./editor").Editor);
	! function () {
		this.insertSnippet = function (e, t) {
			return s.snippetManager.insertSnippet(this, e, t)
		}, this.expandSnippet = function (e) {
			return s.snippetManager.expandWithTab(this, e)
		}
	}.call(i.prototype)
}), define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config"], function (e, t, n) {
	"use strict";

	function a(e) {
		return "suggest-aria-id:".concat(e)
	}

	function c(e) {
		return (e = new i(e)).$maxLines = 4, (e = new r(e)).setHighlightActiveLine(!1), e.setShowPrintMargin(!1), e.renderer.setShowGutter(!1), e.renderer.setHighlightGutterLine(!1), e.$mouseHandler.$focusTimeout = 0, e.$highlightTagPending = !0, e
	}

	function o(e) {
		function t() {}
		var n = g.createElement("div"),
			u = new c(n);

		function o() {
			s(-1)
		}
		e && e.appendChild(n), n.style.display = "none", u.renderer.content.style.cursor = "default", u.renderer.setStyle("ace_autocomplete"), u.renderer.container.setAttribute("role", "listbox"), u.renderer.container.setAttribute("aria-label", f("Autocomplete suggestions")), u.setOption("displayIndentGuides", !1), u.setOption("dragDelay", 150), u.focus = t, u.$isFocused = !0, u.renderer.$cursorLayer.restartTimer = t, u.renderer.$cursorLayer.element.style.opacity = 0, u.renderer.$maxLines = 8, u.renderer.$keepTextAreaAtCursor = !1, u.setHighlightActiveLine(!1), u.session.highlight(""), u.session.$searchHighlight.clazz = "ace_highlight-marker", u.on("mousedown", function (e) {
			var t = e.getDocumentPosition();
			u.selection.moveToPosition(t), r.start.row = r.end.row = t.row, e.stop()
		});
		var d, i = new p(-1, 0, -1, 1 / 0),
			r = new p(-1, 0, -1, 1 / 0),
			s = (r.id = u.session.addMarker(r, "ace_active-line", "fullLine"), u.setSelectOnHover = function (e) {
				e ? i.id && (u.session.removeMarker(i.id), i.id = null) : i.id = u.session.addMarker(i, "ace_line-hover", "fullLine")
			}, u.setSelectOnHover(!1), u.on("mousemove", function (e) {
				var t;
				d ? d.x == e.x && d.y == e.y || ((d = e).scrollTop = u.renderer.scrollTop, t = d.getDocumentPosition().row, i.start.row != t && (i.id || u.setRow(t), s(t))) : d = e
			}), u.renderer.on("beforeRender", function () {
				var e;
				d && -1 != i.start.row && (d.$pos = null, e = d.getDocumentPosition().row, i.id || u.setRow(e), s(e, !0))
			}), u.renderer.on("afterRender", function () {
				var e = u.getRow(),
					t = u.renderer.$textLayer,
					n = t.element.childNodes[e - t.config.firstRow],
					o = document.activeElement;
				n !== t.selectedNode && t.selectedNode && (g.removeCssClass(t.selectedNode, "ace_selected"), o.removeAttribute("aria-activedescendant"), t.selectedNode.removeAttribute("id")), (t.selectedNode = n) && (g.addCssClass(n, "ace_selected"), t = a(e), n.id = t, u.renderer.container.setAttribute("aria-activedescendant", t), o.setAttribute("aria-activedescendant", t), n.setAttribute("role", "option"), n.setAttribute("aria-label", u.getData(e).value), n.setAttribute("aria-setsize", u.data.length), n.setAttribute("aria-posinset", e), n.setAttribute("aria-describedby", "doc-tooltip"))
			}), function (e, t) {
				e !== i.start.row && (i.start.row = i.end.row = e, t || u.session._emit("changeBackMarker"), u._emit("changeHoverMarker"))
			});
		return u.getHoveredRow = function () {
			return i.start.row
		}, l.addListener(u.container, "mouseout", o), u.on("hide", o), u.on("changeSelection", o), u.session.doc.getLength = function () {
			return u.data.length
		}, u.session.doc.getLine = function (e) {
			e = u.data[e];
			return "string" == typeof e ? e : e && e.value || ""
		}, (e = u.session.bgTokenizer).$tokenizeRow = function (e) {
			function t(e, t) {
				e && o.push({
					type: (n.className || "") + (t || ""),
					value: e
				})
			}
			var n = u.data[e],
				o = [];
			if (!n) return o;
			for (var i = (n = "string" == typeof n ? {
					value: n
				} : n).caption || n.value || n.name, r = i.toLowerCase(), s = (u.filterText || "").toLowerCase(), a = 0, c = 0, p = 0; p <= s.length; p++)
				if (p != c && (n.matchMask & 1 << p || p == s.length)) {
					var l = s.slice(c, p),
						c = p,
						h = r.indexOf(l, a);
					if (-1 == h) continue;
					t(i.slice(a, h), ""), a = h + l.length, t(i.slice(h, a), "completion-highlight")
				}
			return t(i.slice(a, i.length), ""), o.push({
				type: "completion-spacer",
				value: " "
			}), n.meta && o.push({
				type: "completion-meta",
				value: n.meta
			}), n.message && o.push({
				type: "completion-message",
				value: n.message
			}), o
		}, e.$updateOnChange = t, e.start = t, u.session.$computeWidth = function () {
			return this.screenWidth = 0
		}, u.isOpen = !1, u.isTopdown = !1, u.autoSelect = !0, u.filterText = "", u.data = [], u.setData = function (e, t) {
			u.filterText = t || "", u.setValue(h.stringRepeat("\n", e.length), -1), u.data = e || [], u.setRow(0)
		}, u.getData = function (e) {
			return u.data[e]
		}, u.getRow = function () {
			return r.start.row
		}, u.setRow = function (e) {
			e = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, e)), r.start.row != e && (u.selection.clearSelection(), r.start.row = r.end.row = e || 0, u.session._emit("changeBackMarker"), u.moveCursorTo(e || 0, 0), u.isOpen && u._signal("select"))
		}, u.on("changeSelection", function () {
			u.isOpen && u.setRow(u.selection.lead.row), u.renderer.scrollCursorIntoView()
		}), u.hide = function () {
			this.container.style.display = "none", u.anchorPos = null, u.anchor = null, u.isOpen && (u.isOpen = !1, this._signal("hide"))
		}, u.tryShow = function (e, t, n, o) {
			if (!o && u.isOpen && u.anchorPos && u.anchor && u.anchorPos.top === e.top && u.anchorPos.left === e.left && u.anchor === n) return !0;
			var i = this.container,
				r = window.innerHeight,
				s = window.innerWidth,
				a = this.renderer,
				c = a.$maxLines * t * 1.4,
				p = {
					top: 0,
					bottom: 0,
					left: 0
				},
				l = r - e.top - 3 * this.$borderSize - t,
				h = e.top - 3 * this.$borderSize,
				t = ("top" === (n = n || (h <= l || c <= l ? "bottom" : "top")) ? (p.bottom = e.top - this.$borderSize, p.top = p.bottom - c) : "bottom" === n && (p.top = e.top + t + this.$borderSize, p.bottom = p.top + c), 0 <= p.top && p.bottom <= r);
			if (!o && !t) return !1;
			a.$maxPixelHeight = t ? null : "top" === n ? h : l, "top" === n ? (i.style.top = "", i.style.bottom = r - p.bottom + "px", u.isTopdown = !1) : (i.style.top = p.top + "px", i.style.bottom = "", u.isTopdown = !0), i.style.display = "";
			c = e.left;
			return c + i.offsetWidth > s && (c = s - i.offsetWidth), i.style.left = c + "px", i.style.right = "", u.isOpen || (u.isOpen = !0, this._signal("show"), d = null), u.anchorPos = e, u.anchor = n, !0
		}, u.show = function (e, t, n) {
			this.tryShow(e, t, n ? "bottom" : void 0, !0)
		}, u.goTo = function (e) {
			var t = this.getRow(),
				n = this.session.getLength() - 1;
			switch (e) {
				case "up":
					t = t <= 0 ? n : t - 1;
					break;
				case "down":
					t = n <= t ? -1 : t + 1;
					break;
				case "start":
					t = 0;
					break;
				case "end":
					t = n
			}
			this.setRow(t)
		}, u.getTextLeftOffset = function () {
			return this.$borderSize + this.renderer.$padding + this.$imageSize
		}, u.$imageSize = 0, u.$borderSize = 1, u
	}
	var i = e("../virtual_renderer").VirtualRenderer,
		r = e("../editor").Editor,
		p = e("../range").Range,
		l = e("../lib/event"),
		h = e("../lib/lang"),
		g = e("../lib/dom"),
		f = e("../config").nls;
	g.importCssString("\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n", "autocompletion.css", !1), t.AcePopup = o, t.$singleLineEditor = c, t.getAriaId = a
}), define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets"], function (e, t, n) {
	"use strict";
	var o = e("../snippets").snippetManager;

	function i() {
		this.editor = null
	}
	i.prototype.show = function (e, t, n) {
		if (n = n || "", e && this.editor && this.editor !== e && (this.hide(), this.editor = null), !e || !t) return !1;
		t = t.snippet ? o.getDisplayTextForSnippet(e, t.snippet) : t.value;
		return !(!t || !t.startsWith(n)) && (this.editor = e, "" === (t = t.slice(n.length)) ? e.removeGhostText() : e.setGhostText(t), !0)
	}, i.prototype.isOpen = function () {
		return !!this.editor && !!this.editor.renderer.$ghostText
	}, i.prototype.hide = function () {
		return !!this.editor && (this.editor.removeGhostText(), !0)
	}, i.prototype.destroy = function () {
		this.hide(), this.editor = null
	}, t.AceInline = i
}), define("ace/autocomplete/util", ["require", "exports", "module"], function (e, t, n) {
	"use strict";
	t.parForEach = function (e, t, n) {
		var o = 0,
			i = e.length;
		0 === i && n();
		for (var r = 0; r < i; r++) t(e[r], function (e, t) {
			++o === i && n(e, t)
		})
	};
	var r = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
	t.retrievePrecedingIdentifier = function (e, t, n) {
		n = n || r;
		for (var o = [], i = t - 1; 0 <= i && n.test(e[i]); i--) o.push(e[i]);
		return o.reverse().join("")
	}, t.retrieveFollowingIdentifier = function (e, t, n) {
		n = n || r;
		for (var o = [], i = t; i < e.length && n.test(e[i]); i++) o.push(e[i]);
		return o
	}, t.getCompletionPrefix = function (e) {
		var t, n = e.getCursorPosition(),
			o = e.session.getLine(n.row);
		return e.completers.forEach(function (e) {
			e.identifierRegexps && e.identifierRegexps.forEach(function (e) {
				!t && e && (t = this.retrievePrecedingIdentifier(o, n.column, e))
			}.bind(this))
		}.bind(this)), t || this.retrievePrecedingIdentifier(o, n.column)
	}, t.triggerAutocomplete = function (e) {
		var t = e.getCursorPosition(),
			n = e.session.getLine(t.row)[0 === t.column ? 0 : t.column - 1];
		return e.completers.some(function (e) {
			if (e.triggerCharacters && Array.isArray(e.triggerCharacters)) return e.triggerCharacters.includes(n)
		})
	}
}), define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config"], function (e, t, n) {
	"use strict";

	function o(e, t) {
		t.completer && t.completer.destroy()
	}
	var i = e("./keyboard/hash_handler").HashHandler,
		r = e("./autocomplete/popup").AcePopup,
		s = e("./autocomplete/inline").AceInline,
		a = e("./autocomplete/popup").getAriaId,
		p = e("./autocomplete/util"),
		c = e("./lib/lang"),
		l = e("./lib/dom"),
		h = e("./snippets").snippetManager,
		u = e("./config"),
		d = (g.prototype.$init = function () {
			return this.popup = new r(this.parentNode || document.body || document.documentElement), this.popup.on("click", function (e) {
				this.insertMatch(), e.stop()
			}.bind(this)), this.popup.focus = this.editor.focus.bind(this.editor), this.popup.on("show", this.$onPopupChange.bind(this)), this.popup.on("hide", this.$onHidePopup.bind(this)), this.popup.on("select", this.$onPopupChange.bind(this)), this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null)), this.popup
		}, g.prototype.$initInline = function () {
			if (this.inlineEnabled && !this.inlineRenderer) return this.inlineRenderer = new s, this.inlineRenderer
		}, g.prototype.getPopup = function () {
			return this.popup || this.$init()
		}, g.prototype.$onHidePopup = function () {
			this.inlineRenderer && this.inlineRenderer.hide(), this.hideDocTooltip()
		}, g.prototype.$onPopupChange = function (e) {
			var t;
			this.inlineRenderer && this.inlineEnabled && (e = e ? null : this.popup.getData(this.popup.getRow()), t = p.getCompletionPrefix(this.editor), this.inlineRenderer.show(this.editor, e, t) || this.inlineRenderer.hide(), this.$updatePopupPosition()), this.tooltipTimer.call(null, null)
		}, g.prototype.observeLayoutChanges = function () {
			if (!this.$elements && this.editor) {
				window.addEventListener("resize", this.onLayoutChange, {
					passive: !0
				}), window.addEventListener("wheel", this.mousewheelListener);
				for (var e = this.editor.container.parentNode, t = []; e;) t.push(e), e.addEventListener("scroll", this.onLayoutChange, {
					passive: !0
				}), e = e.parentNode;
				this.$elements = t
			}
		}, g.prototype.unObserveLayoutChanges = function () {
			var t = this;
			window.removeEventListener("resize", this.onLayoutChange, {
				passive: !0
			}), window.removeEventListener("wheel", this.mousewheelListener), this.$elements && this.$elements.forEach(function (e) {
				e.removeEventListener("scroll", t.onLayoutChange, {
					passive: !0
				})
			}), this.$elements = null
		}, g.prototype.onLayoutChange = function () {
			if (!this.popup.isOpen) return this.unObserveLayoutChanges();
			this.$updatePopupPosition(), this.updateDocTooltip()
		}, g.prototype.$updatePopupPosition = function () {
			var e = this.editor,
				t = e.renderer,
				n = t.layerConfig.lineHeight,
				o = t.$cursorLayer.getPixelPosition(this.base, !0),
				i = (o.left -= this.popup.getTextLeftOffset(), e.container.getBoundingClientRect()),
				i = (o.top += i.top - t.layerConfig.offset, o.left += i.left - e.renderer.scrollLeft, o.left += t.gutterWidth, {
					top: o.top,
					left: o.left
				});
			t.$ghostText && t.$ghostTextWidget && this.base.row === t.$ghostText.position.row && (i.top += t.$ghostTextWidget.el.offsetHeight), this.popup.tryShow(i, n, "bottom") || this.popup.tryShow(o, n, "top") || this.popup.show(o, n)
		}, g.prototype.openPopup = function (e, t, n) {
			this.popup || this.$init(), this.inlineEnabled && !this.inlineRenderer && this.$initInline(), this.popup.autoSelect = this.autoSelect, this.popup.setData(this.completions.filtered, this.completions.filterText), this.editor.textInput.setAriaOptions && this.editor.textInput.setAriaOptions({
				activeDescendant: a(this.popup.getRow()),
				inline: this.inlineEnabled
			}), e.keyBinding.addKeyboardHandler(this.keyboardHandler), this.popup.setRow(this.autoSelect ? 0 : -1), n ? t || this.detach() : (this.popup.setTheme(e.getTheme()), this.popup.setFontSize(e.getFontSize()), this.$updatePopupPosition(), this.tooltipNode && this.updateDocTooltip()), this.changeTimer.cancel(), this.observeLayoutChanges()
		}, g.prototype.detach = function () {
			this.editor && (this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.off("changeSelection", this.changeListener), this.editor.off("blur", this.blurListener), this.editor.off("mousedown", this.mousedownListener), this.editor.off("mousewheel", this.mousewheelListener)), this.changeTimer.cancel(), this.hideDocTooltip(), this.completionProvider && this.completionProvider.detach(), this.popup && this.popup.isOpen && this.popup.hide(), this.base && this.base.detach(), this.activated = !1, this.completionProvider = this.completions = this.base = null, this.unObserveLayoutChanges()
		}, g.prototype.changeListener = function (e) {
			var t = this.editor.selection.lead;
			(t.row != this.base.row || t.column < this.base.column) && this.detach(), this.activated ? this.changeTimer.schedule() : this.detach()
		}, g.prototype.blurListener = function (e) {
			var t = document.activeElement,
				n = this.editor.textInput.getElement(),
				o = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget),
				i = this.popup && this.popup.container;
			t == n || t.parentNode == i || o || t == this.tooltipNode || e.relatedTarget == n || this.detach()
		}, g.prototype.mousedownListener = function (e) {
			this.detach()
		}, g.prototype.mousewheelListener = function (e) {
			this.detach()
		}, g.prototype.goTo = function (e) {
			this.popup.goTo(e)
		}, g.prototype.insertMatch = function (e, t) {
			if (!(e = e || this.popup.getData(this.popup.getRow()))) return !1;
			if ("" === e.value) return this.detach();
			var n = this.completions,
				e = this.getCompletionProvider().insertMatch(this.editor, e, n.filterText, t);
			return this.completions == n && this.detach(), e
		}, g.prototype.showPopup = function (e, t) {
			this.editor && this.detach(), this.activated = !0, (this.editor = e).completer != this && (e.completer && e.completer.detach(), e.completer = this), e.on("changeSelection", this.changeListener), e.on("blur", this.blurListener), e.on("mousedown", this.mousedownListener), e.on("mousewheel", this.mousewheelListener), this.updateCompletions(!1, t)
		}, g.prototype.getCompletionProvider = function () {
			return this.completionProvider || (this.completionProvider = new f), this.completionProvider
		}, g.prototype.gatherCompletions = function (e, t) {
			return this.getCompletionProvider().gatherCompletions(e, t)
		}, g.prototype.updateCompletions = function (r, e) {
			if (r && this.base && this.completions) return t = this.editor.getCursorPosition(), (n = this.editor.session.getTextRange({
				start: this.base,
				end: t
			})) == this.completions.filterText ? void 0 : (this.completions.setFilter(n), this.completions.filtered.length && (1 != this.completions.filtered.length || this.completions.filtered[0].value != n || this.completions.filtered[0].snippet) ? void this.openPopup(this.editor, n, r) : this.detach());
			if (e && e.matches) return t = this.editor.getSelectionRange().start, this.base = this.editor.session.doc.createAnchor(t.row, t.column), this.base.$insertRight = !0, this.completions = new m(e.matches), this.openPopup(this.editor, "", r);
			var e = this.editor.getSession(),
				t = this.editor.getCursorPosition(),
				n = p.getCompletionPrefix(this.editor),
				e = (this.base = e.doc.createAnchor(t.row, t.column - n.length), this.base.$insertRight = !0, {
					exactMatch: this.exactMatch
				});
			this.getCompletionProvider().provideCompletions(this.editor, e, function (e, t, n) {
				var o = t.filtered,
					i = p.getCompletionPrefix(this.editor);
				if (n) {
					if (!o.length) return (n = "function" == typeof (n = !this.autoShown && this.emptyMessage) ? this.emptyMessage(i) : n) ? (n = [{
						caption: this.emptyMessage(i),
						value: ""
					}], this.completions = new m(n), void this.openPopup(this.editor, i, r)) : this.detach();
					if (1 == o.length && o[0].value == i && !o[0].snippet) return this.detach();
					if (this.autoInsert && !this.autoShown && 1 == o.length) return this.insertMatch(o[0])
				}
				this.completions = t, this.openPopup(this.editor, i, r)
			}.bind(this))
		}, g.prototype.cancelContextMenu = function () {
			this.editor.$mouseHandler.cancelContextMenu()
		}, g.prototype.updateDocTooltip = function () {
			var e = this.popup,
				t = e.data,
				n = t && (t[e.getHoveredRow()] || t[e.getRow()]),
				o = null;
			if (!n || !this.editor || !this.popup.isOpen) return this.hideDocTooltip();
			for (var i = this.editor.completers.length, r = 0; r < i; r++) {
				var s = this.editor.completers[r];
				if (s.getDocTooltip && n.completerId === s.id) {
					o = s.getDocTooltip(n);
					break
				}
			}
			if (!(o = "string" == typeof (o = o || "string" == typeof n ? o : n) ? {
					docText: o
				} : o) || !o.docHTML && !o.docText) return this.hideDocTooltip();
			this.showDocTooltip(o)
		}, g.prototype.showDocTooltip = function (e) {
			this.tooltipNode || (this.tooltipNode = l.createElement("div"), this.tooltipNode.style.margin = 0, this.tooltipNode.style.pointerEvents = "auto", this.tooltipNode.tabIndex = -1, this.tooltipNode.onblur = this.blurListener.bind(this), this.tooltipNode.onclick = this.onTooltipClick.bind(this), this.tooltipNode.id = "doc-tooltip", this.tooltipNode.setAttribute("role", "tooltip"));
			var t = this.editor.renderer.theme,
				t = (this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (t.isDark ? "ace_dark " : "") + (t.cssClass || ""), this.tooltipNode),
				e = (e.docHTML ? t.innerHTML = e.docHTML : e.docText && (t.textContent = e.docText), t.parentNode || this.popup.container.appendChild(this.tooltipNode), this.popup),
				n = e.container.getBoundingClientRect();
			t.style.top = e.container.style.top, t.style.bottom = e.container.style.bottom, t.style.display = "block", window.innerWidth - n.right < 320 ? n.left < 320 ? (e.isTopdown ? t.style.top = n.bottom + "px" : t.style.top = e.container.offsetTop - t.offsetHeight + "px", t.style.left = n.left + "px", t.style.right = "", t.style.bottom = "") : (t.style.right = window.innerWidth - n.left + "px", t.style.left = "") : (t.style.left = n.right + 1 + "px", t.style.right = "")
		}, g.prototype.hideDocTooltip = function () {
			var e;
			this.tooltipTimer.cancel(), this.tooltipNode && (e = this.tooltipNode, this.editor.isFocused() || document.activeElement != e || this.editor.focus(), this.tooltipNode = null, e.parentNode && e.parentNode.removeChild(e))
		}, g.prototype.onTooltipClick = function (e) {
			for (var t = e.target; t && t != this.tooltipNode;) {
				if ("A" == t.nodeName && t.href) {
					t.rel = "noreferrer", t.target = "_blank";
					break
				}
				t = t.parentNode
			}
		}, g.prototype.destroy = function () {
			var e;
			this.detach(), this.popup && (this.popup.destroy(), (e = this.popup.container) && e.parentNode && e.parentNode.removeChild(e)), this.editor && this.editor.completer == this && (this.editor.off("destroy", o), this.editor.completer = null), this.inlineRenderer = this.popup = this.editor = null
		}, g);

	function g() {
		this.autoInsert = !1, this.autoSelect = !0, this.autoShown = !1, this.exactMatch = !1, this.inlineEnabled = !1, this.keyboardHandler = new i, this.keyboardHandler.bindKeys(this.commands), this.parentNode = null, this.blurListener = this.blurListener.bind(this), this.changeListener = this.changeListener.bind(this), this.mousedownListener = this.mousedownListener.bind(this), this.mousewheelListener = this.mousewheelListener.bind(this), this.onLayoutChange = this.onLayoutChange.bind(this), this.changeTimer = c.delayedCall(function () {
			this.updateCompletions(!0)
		}.bind(this)), this.tooltipTimer = c.delayedCall(this.updateDocTooltip.bind(this), 50)
	}
	d.prototype.commands = {
		Up: function (e) {
			e.completer.goTo("up")
		},
		Down: function (e) {
			e.completer.goTo("down")
		},
		"Ctrl-Up|Ctrl-Home": function (e) {
			e.completer.goTo("start")
		},
		"Ctrl-Down|Ctrl-End": function (e) {
			e.completer.goTo("end")
		},
		Esc: function (e) {
			e.completer.detach()
		},
		Return: function (e) {
			return e.completer.insertMatch()
		},
		"Shift-Return": function (e) {
			e.completer.insertMatch(null, {
				deleteSuffix: !0
			})
		},
		Tab: function (e) {
			var t = e.completer.insertMatch();
			if (t || e.tabstopManager) return t;
			e.completer.goTo("down")
		},
		PageUp: function (e) {
			e.completer.popup.gotoPageUp()
		},
		PageDown: function (e) {
			e.completer.popup.gotoPageDown()
		}
	}, d.for = function (e) {
		return e.completer instanceof d || (e.completer && (e.completer.destroy(), e.completer = null), u.get("sharedPopups") ? (d.$sharedInstance || (d.$sharedInstance = new d), e.completer = d.$sharedInstance) : (e.completer = new d, e.once("destroy", o))), e.completer
	}, d.startCommand = {
		name: "startAutocomplete",
		exec: function (e, t) {
			var n = d.for(e);
			n.autoInsert = !1, n.autoSelect = !0, n.autoShown = !1, n.showPopup(e, t), n.cancelContextMenu()
		},
		bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
	};
	v.prototype.insertByIndex = function (e, t, n) {
		return !(!this.completions || !this.completions.filtered) && this.insertMatch(e, this.completions.filtered[t], n)
	}, v.prototype.insertMatch = function (e, t, n) {
		if (!t) return !1;
		if (e.startOperation({
				command: {
					name: "insertMatch"
				}
			}), t.completer && t.completer.insertMatch) t.completer.insertMatch(e, t);
		else {
			if (!this.completions) return !1;
			if (this.completions.filterText)
				for (var o, i = e.selection.getAllRanges ? e.selection.getAllRanges() : [e.getSelectionRange()], r = 0; o = i[r]; r++) o.start.column -= this.completions.filterText.length, e.session.remove(o);
			t.snippet ? h.insertSnippet(e, t.snippet, {
				range: t.range
			}) : this.$insertString(e, t), t.command && "startAutocomplete" === t.command && e.execCommand(t.command)
		}
		return e.endOperation(), !0
	}, v.prototype.$insertString = function (t, n) {
		var o = n.value || n;
		if (n.range) {
			if (t.inVirtualSelectionMode) return t.session.replace(n.range, o);
			t.forEachSelection(function () {
				var e = t.getSelectionRange();
				0 === n.range.compareRange(e) ? t.session.replace(n.range, o) : t.insert(o)
			}, null, {
				keepOrder: !0
			})
		} else t.execCommand("insertstring", o)
	}, v.prototype.gatherCompletions = function (n, o) {
		var i = n.getSession(),
			r = n.getCursorPosition(),
			s = p.getCompletionPrefix(n),
			a = [],
			c = (this.completers = n.completers, n.completers.length);
		return n.completers.forEach(function (e, t) {
			e.getCompletions(n, i, r, s, function (e, t) {
				!e && t && (a = a.concat(t)), o(null, {
					prefix: p.getCompletionPrefix(n),
					matches: a,
					finished: 0 == --c
				})
			})
		}), !0
	}, v.prototype.provideCompletions = function (e, o, i) {
		var n = function (e) {
				var t = e.prefix,
					n = e.matches;
				this.completions = new m(n), o.exactMatch && (this.completions.exactMatch = !0), o.ignoreCaption && (this.completions.ignoreCaption = !0), this.completions.setFilter(t), (e.finished || this.completions.filtered.length) && i(null, this.completions, e.finished)
			}.bind(this),
			r = !0,
			s = null;
		this.gatherCompletions(e, function (e, t) {
			this.active && (e && (i(e, [], !0), this.detach()), 0 === t.prefix.indexOf(t.prefix) && (r ? s = t : n(t)))
		}.bind(this)), r = !1, s && (e = s, s = null, n(e))
	}, v.prototype.detach = function () {
		this.active = !1, this.completers && this.completers.forEach(function (e) {
			"function" == typeof e.cancel && e.cancel()
		})
	};
	var f = v,
		m = (b.prototype.setFilter = function (e) {
			t = e.length > this.filterText && 0 === e.lastIndexOf(this.filterText, 0) ? this.filtered : this.all, this.filterText = e, t = (t = this.filterCompletions(t, this.filterText)).sort(function (e, t) {
				return t.exactMatch - e.exactMatch || t.$score - e.$score || (e.caption || e.value).localeCompare(t.caption || t.value)
			});
			var t, n = null;
			t = t.filter(function (e) {
				e = e.snippet || e.caption || e.value;
				return e !== n && (n = e, !0)
			}), this.filtered = t
		}, b.prototype.filterCompletions = function (e, t) {
			var n = [],
				o = t.toUpperCase(),
				i = t.toLowerCase();
			e: for (var r, s = 0; r = e[s]; s++) {
				var a = !this.ignoreCaption && r.caption || r.value || r.snippet;
				if (a) {
					var c = -1,
						p = 0,
						l = 0;
					if (this.exactMatch) {
						if (t !== a.substr(0, t.length)) continue
					} else {
						var h = a.toLowerCase().indexOf(i);
						if (-1 < h) l = h;
						else
							for (var u = 0; u < t.length; u++) {
								var d = a.indexOf(i[u], c + 1),
									g = a.indexOf(o[u], c + 1);
								if ((d = 0 <= d && (g < 0 || d < g) ? d : g) < 0) continue e;
								0 < (g = d - c - 1) && (-1 === c && (l += 10), l += g, p |= 1 << u), c = d
							}
					}
					r.matchMask = p, r.exactMatch = l ? 0 : 1, r.$score = (r.score || 0) - l, n.push(r)
				}
			}
			return n
		}, b);

	function b(e, t) {
		this.all = e, this.filtered = e, this.filterText = t || "", this.exactMatch = !1, this.ignoreCaption = !1
	}

	function v() {
		this.active = !0
	}
	t.Autocomplete = d, t.CompletionProvider = f, t.FilteredList = m
}), define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function (e, t, n) {
	function s(e, t) {
		var n = e.getTextRange(a.fromPoints({
				row: 0,
				column: 0
			}, t)).split(c).length - 1,
			o = e.getValue().split(c),
			i = Object.create(null),
			r = o[n];
		return o.forEach(function (e, t) {
			e && e !== r && (t = Math.abs(n - t), t = o.length - t, i[e] ? i[e] = Math.max(t, i[e]) : i[e] = t)
		}), i
	}
	var a = e("../range").Range,
		c = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
	t.getCompletions = function (e, t, n, o, i) {
		var r = s(t, n);
		i(null, Object.keys(r).map(function (e) {
			return {
				caption: e,
				value: e,
				score: r[e],
				meta: "local"
			}
		}))
	}
}), define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function (e, t, n) {
	"use strict";

	function o(e, t) {
		m(t.session.$mode)
	}

	function i(e) {
		var t = e.editor,
			n = t.completer && t.completer.activated;
		"backspace" === e.command.name ? n && !l.getCompletionPrefix(t) && t.completer.detach() : "insertstring" !== e.command.name || n || ((t = (r = e).editor.$liveAutocompletionDelay) ? v.delay(t) : x(e))
	}
	var r, c = e("../snippets").snippetManager,
		s = e("../autocomplete").Autocomplete,
		a = e("../config"),
		p = e("../lib/lang"),
		l = e("../autocomplete/util"),
		h = e("../autocomplete/text_completer"),
		u = {
			getCompletions: function (e, t, n, o, i) {
				if (t.$mode.completer) return t.$mode.completer.getCompletions(e, t, n, o, i);
				e = e.session.getState(n.row);
				i(null, t.$mode.getCompletions(e, t, n, o).map(function (e) {
					return e.completerId = u.id, e
				}))
			},
			id: "keywordCompleter"
		},
		d = {
			getCompletions: function (e, t, n, o, i) {
				var r = [],
					t = t.getTokenAt(n.row, n.column),
					s = (t && t.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/) ? r.push("html-tag") : r = c.getActiveScopes(e), c.snippetMap),
					a = [];
				r.forEach(function (e) {
					for (var t = s[e] || [], n = t.length; n--;) {
						var o = t[n],
							i = o.name || o.tabTrigger;
						i && a.push({
							caption: i,
							snippet: o.content,
							meta: o.tabTrigger && !o.name ? o.tabTrigger + "⇥ " : "snippet",
							completerId: d.id
						})
					}
				}, this), i(null, a)
			},
			getDocTooltip: function (e) {
				var i;
				e.snippet && !e.docHTML && (e.docHTML = ["<b>", p.escapeHTML(e.caption), "</b>", "<hr></hr>", p.escapeHTML((e = e.snippet, i = {}, e.replace(/\${(\d+)(:(.*?))?}/g, function (e, t, n, o) {
					return i[t] = o || ""
				}).replace(/\$(\d+?)/g, function (e, t) {
					return i[t]
				})))].join(""))
			},
			id: "snippetCompleter"
		},
		g = [d, h, u],
		f = (t.setCompleters = function (e) {
			g.length = 0, e && g.push.apply(g, e)
		}, t.addCompleter = function (e) {
			g.push(e)
		}, t.textCompleter = h, t.keyWordCompleter = u, t.snippetCompleter = d, {
			name: "expandSnippet",
			exec: function (e) {
				return c.expandWithTab(e)
			},
			bindKey: "Tab"
		}),
		m = function (e) {
			(e = "string" == typeof e ? a.$modes[e] : e) && (c.files || (c.files = {}), b(e.$id, e.snippetFileId), e.modes && e.modes.forEach(m))
		},
		b = function (t, e) {
			e && t && !c.files[t] && (c.files[t] = {}, a.loadModule(e, function (e) {
				e && (!(c.files[t] = e).snippets && e.snippetText && (e.snippets = c.parseSnippetFile(e.snippetText)), c.register(e.snippets || [], e.scope), e.includeScopes && (c.snippetMap[e.scope].includeScopes = e.includeScopes, e.includeScopes.forEach(function (e) {
					m("ace/mode/" + e)
				})))
			}))
		},
		v = p.delayedCall(function () {
			x(r)
		}, 0),
		x = function (e) {
			var e = e.editor,
				t = l.getCompletionPrefix(e),
				n = l.triggerAutocomplete(e);
			(t || n) && t.length >= e.$liveAutocompletionThreshold && ((n = s.for(e)).autoShown = !0, n.showPopup(e))
		},
		h = e("../editor").Editor;
	e("../config").defineOptions(h.prototype, "editor", {
		enableBasicAutocompletion: {
			set: function (e) {
				e ? (this.completers || (this.completers = Array.isArray(e) ? e : g), this.commands.addCommand(s.startCommand)) : this.commands.removeCommand(s.startCommand)
			},
			value: !1
		},
		enableLiveAutocompletion: {
			set: function (e) {
				e ? (this.completers || (this.completers = Array.isArray(e) ? e : g), this.commands.on("afterExec", i)) : this.commands.off("afterExec", i)
			},
			value: !1
		},
		liveAutocompletionDelay: {
			initialValue: 0
		},
		liveAutocompletionThreshold: {
			initialValue: 0
		},
		enableSnippets: {
			set: function (e) {
				e ? (this.commands.addCommand(f), this.on("changeMode", o), o(0, this)) : (this.commands.removeCommand(f), this.off("changeMode", o))
			},
			value: !1
		}
	})
}), window.require(["ace/ext/language_tools"], function (e) {
	"object" == typeof module && "object" == typeof exports && module && (module.exports = e)
});
